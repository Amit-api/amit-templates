<#import "macros.ftl" as my>
<#assign modelJavaPackage = my.getJavaPackage() >
<#assign thisJavaPackage = modelJavaPackage + ".server.netty" >
<#assign intrfJavaPackage = modelJavaPackage + ".intrf.async" >
<#assign callJavaPackage = modelJavaPackage + ".json.call" > 
<#assign objectName = object.getName() >
<#assign className = objectName + "HttpHandler" > 

/**
 * This file is generated by the Amit
 * don't modify it manually
 */
package ${thisJavaPackage};

import com.amitapi.netty.server.HttpRequestHandler;
import com.amitapi.netty.server.UrlMapHttpRequestHandler;
import com.amitapi.netty.server.ErrorHttpRequestHandler;

import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.util.CharsetUtil;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.buffer.Unpooled;
import io.netty.handler.codec.http.HttpResponseStatus;

import java.util.concurrent.CompletableFuture;
import java.io.IOException;

import com.fasterxml.jackson.core.JsonParseException;

import ${modelJavaPackage}.exception.ValidationException;
import ${modelJavaPackage}.exception.ServerException;
import ${modelJavaPackage}.exception.InternalException;

public final class ${className} {
	
<#list object.getBaseInterfaceNames() as interfaceName > 
	<#assign ainterfaceName = interfaceName?uncap_first > 
	/**
	 * interface ${interfaceName}
	 */
	private ${intrfJavaPackage}.${interfaceName} __${ainterfaceName};
	
	public void registerInterface( ${intrfJavaPackage}.${interfaceName} value, UrlMapHttpRequestHandler parent ) {
		if( __${ainterfaceName} != null ) {
			throw new IllegalArgumentException( "interface ${interfaceName} is already registered" );
		}
		
		this.__${ainterfaceName} = value; 
		
	<#assign interfaceObj = project.getInterface( interfaceName ) >	
		<#list interfaceObj.getFunctions() as function >
		<#assign fname = function.getName() >
		<#assign ARfname = fname?cap_first + "Request"  >
		<#assign APfname = fname?cap_first + "Response" >
		<#assign returnType = function.getReturn().getTypeName() >
		<#assign requestClass = callJavaPackage + ".Call"+ interfaceName +"." + ARfname >
		<#assign responseClass = callJavaPackage + ".Call"+ interfaceName + "." + APfname >
		<#assign build = "Build." + fname>
		
		/**
		 * ${interfaceName}.${fname}
		 */
		parent.registerHandler(
			"/api/${objectName?lower_case}/${fname?lower_case}",
			new HttpRequestHandler() {
				public CompletableFuture<FullHttpResponse> process(FullHttpRequest request) {
					${requestClass} requestObject = null;
					try {
						requestObject = ${requestClass}.parseJson(
							request.content().toString(CharsetUtil.UTF_8));
						requestObject.validate();
					} catch(JsonParseException e) {
						return ${build}.aresult(new ValidationException().withCode("json").withReason(e.getMessage()), 
							HttpResponseStatus.BAD_REQUEST);						
					} catch(ValidationException e) {
						return ${build}.aresult(e, HttpResponseStatus.BAD_REQUEST);
					} catch (IOException e) {
						return ${build}.aresult(new InternalException().withReason(e.getMessage()), 
								HttpResponseStatus.INTERNAL_SERVER_ERROR);				
					}
					
					CompletableFuture<FullHttpResponse> result = new CompletableFuture<FullHttpResponse>();
					__${ainterfaceName}.${fname}(
			<#list function.getArguments() as arg >
				<#assign aname = arg.getName() >
						requestObject.get${aname?cap_first}()<#if arg_has_next>,</#if>
			</#list>
					).handle((responseObject, ex) -> {
						if(ex != null) {
			<#list function.getThrowsExceptionNames() as exceptionName>
							if(ex instanceof ${modelJavaPackage}.${exceptionName}) {
								result.complete(${build}.result( new ${responseClass}().withException(
									(${modelJavaPackage}.${exceptionName}) ex), HttpResponseStatus.BAD_REQUEST));
							}
			</#list>
						
							result.complete(${build}.result(new InternalException().withReason(ex.getMessage()), 
								HttpResponseStatus.INTERNAL_SERVER_ERROR));
						} else {
			<#if returnType == "void" >
							result.complete(Build.result("", HttpResponseStatus.OK));
			<#else>
							result.complete(${build}.result(
								new ${responseClass}().withReturnValue(responseObject), HttpResponseStatus.OK));
			</#if>		
						}
						return responseObject;
					});
					return result;
				}
			}				
		);
		</#list>
</#list>
	}

	private static class Build {
		public static FullHttpResponse result(String content, HttpResponseStatus status) {
			FullHttpResponse httpr = new DefaultFullHttpResponse(
					HttpVersion.HTTP_1_1, status, Unpooled.copiedBuffer(content, CharsetUtil.UTF_8));
			httpr.headers().set(HttpHeaderNames.CONTENT_TYPE, "application/json; charset=UTF-8" );
			return httpr;
		}
		
<#list object.getBaseInterfaceNames() as interfaceName > 
	<#assign ainterfaceName = interfaceName?uncap_first > 
	<#assign interfaceObj = project.getInterface( interfaceName ) >	
	<#list interfaceObj.getFunctions() as function >
		<#assign fname = function.getName() >
		<#assign ARfname = fname?cap_first + "Request"  >
		<#assign APfname = fname?cap_first + "Response" >
		<#assign returnType = function.getReturn().getTypeName() >
		<#assign requestClass = callJavaPackage + ".Call"+ interfaceName +"." + ARfname >
		<#assign responseClass = callJavaPackage + ".Call"+ interfaceName + "." + APfname >

		public static class ${fname} {
			public static FullHttpResponse result(${responseClass} response, HttpResponseStatus status) {
				String message = "";
				try {
					message = response.toJsonString();
				} catch(Exception ex) {
					status = HttpResponseStatus.INTERNAL_SERVER_ERROR;
				}				
				return Build.result(message, status);
			}
			public static FullHttpResponse result(ServerException ex, HttpResponseStatus status) {
				return result(
					new ${responseClass}().withException(ex),
					status
				);
			}
			public static CompletableFuture<FullHttpResponse> aresult(ServerException ex, HttpResponseStatus status) {
				return CompletableFuture.completedFuture(result(ex, status));
			}
		}
	</#list>
</#list>
	}
}
