<#import "macros.ftl" as my>
<#assign modelJavaPackage = my.getJavaPackage() >
<#assign thisJavaPackage = modelJavaPackage + ".json.call" >
<#assign objectName = object.getName() >
<#assign className = 'Call'+ objectName >
<#assign serializerPrefix= modelJavaPackage + ".json." >
/**
 * This file is generated by the Amit
 * don't modify it manually
 */
package ${thisJavaPackage};

import ${modelJavaPackage}.exception.ValidationException;

public final class ${className} {

<#list object.getFunctions() as function >
	<#assign fname = function.getName() >
	<#assign ARfname = fname?cap_first + "Request"  >
	<#assign APfname = fname?cap_first + "Response" >
	<#assign baseClassName="" >
	<#assign returnTypeName = function.getReturn().getTypeName() >
	<#assign returnType = my.javaType( function.getReturn() ) >
	<#assign returnTypeNoArray = my.javaTypeNoArray( function.getReturn() ) >
	<#assign exceptions = function.getThrowsExceptionNames() >
	<#assign allExceptions = project.getExceptionTypeChildren( exceptions ) >
	<#assign returnTypeIsArray = function.getReturn().isArray() >
	<#assign returnTypeIsMap = function.getReturn().isMap() >
	<#assign readFunctionName = "readValue">
	<#if returnTypeIsArray>
		<#assign readFunctionName = "readValueArray" >
	</#if>
	<#if returnTypeIsMap>
		<#assign readFunctionName = "readValueMap" >
	</#if>
	<#assign typesToValidate = function.getTypesToValidate() > 	
/**************************************************************************************************************
 * function ${ARfname}
 * 
 **************************************************************************************************************/
public static final class ${ARfname} {
<@my.classMembers items=function.getArguments() />
<@my.classGettersSetters items=function.getArguments() className=ARfname />

<@my.hashCodeFunction items=function.getArguments() />

<@my.equalsFunction items=function.getArguments() className=ARfname />

<@my.toStringFunction items=function.getArguments() className=ARfname />
		
	/**
	 * validate the ${ARfname} request
	 */
	public void validate() throws ValidationException {
		// validate this level
<#list function.getArgumentConditions() as fcond >
	<#if !fcond.isValidationName() >
	<#assign getterName = "get" + fcond.getName()?cap_first +"()" >
	<#assign member = function.getArgument(fcond.getName()) >
	<#assign javaType = my.javaTypeNoArray(member) >

	<#if fcond.isArray() >
		<#assign data = "item">
		// check field ${member.getTypeName()}[] ${fcond.getName()}
		for( ${javaType} item : ${getterName} ) {
	<#elseif fcond.isMap() >
		<#assign data = "item">
		// check field ${member.getTypeName()}{} ${fcond.getName()}
		for( ${javaType} item : ${getterName}.values() ) {
	<#else>
		<#assign data = getterName>
		// check field ${member.getTypeName()} ${fcond.getName()}
	</#if>
	<#list fcond.getConditions() as cond >
		<@my.validationCondition cond=cond  prefix="\"*\"" field=data />
	</#list>
	<#if fcond.isArray() >
		}
	<#elseif fcond.isMap() >
		}
	<#else>
	</#if>
	</#if>
</#list>

		// validate next level
<#list function.getArguments() as member >
	<#assign memberTypeName = member.getTypeName() >
	<#assign memberjavaType = my.javaTypeNoArray(member) >
	<#assign getterName = "get" + member.getName()?cap_first +"()" >
	<#if typesToValidate?seq_contains(memberTypeName) >
		if( ${getterName} != null ) {
	<#if member.isArray() >
			for( ${memberjavaType} item : ${getterName} ) {
				TypeValidators.validate_${memberTypeName}( "*.${member.getName()}", item );
			}
	<#elseif member.isMap() >
			for( ${memberjavaType} item : object.${getterName}.values() ) {
				TypeValidators.validate_${memberTypeName}( "*.${member.getName()}", item );
			}
	<#else>
			TypeValidators.validate_${memberTypeName}( "*.${member.getName()}", ${getterName} );
	</#if>
		}
	</#if>
</#list>
	}
	
	protected static class TypeValidators {
	<#list typesToValidate as vtype >
		protected static void validate_${vtype}( java.lang.String prefix, ${modelJavaPackage}.${vtype} object ) throws ValidationException {
		<#list function.getValidationsForTypeName(vtype) as vitem>
			// ${vitem.getName()}
			<#if vitem.getTypeName() == vtype >
			${modelJavaPackage}.validation.${vitem.getName()}Validation.validate( prefix, object );
			<#else>
			if( object instanceof ${modelJavaPackage}.${vitem.getTypeName()} ) {
				${modelJavaPackage}.validation.${vitem.getName()}Validation.validate( prefix, 
					(${modelJavaPackage}.${vitem.getTypeName()})object );
			}
			</#if>
		</#list>
		<#assign ctype = project.getType(vtype) >
		<#list ctype.getMembers() as member >
			<#assign memberTypeName = member.getTypeName() >
			<#assign memberjavaType = my.javaTypeNoArray(member) >
			<#assign getterName = "get" + member.getName()?cap_first +"()" >
			<#if typesToValidate?seq_contains(memberTypeName) >
				if( object.${getterName} != null ) {
				<#if member.isArray() >
					for( ${memberjavaType} item : object.${getterName} ) {
						validate_${memberTypeName}( prefix + ".${member.getName()}", item );
					}
				<#elseif member.isMap() >
					for( ${memberjavaType} item : object.${getterName}.values() ) {
						validate_${memberTypeName}( prefix + ".${member.getName()}", item );
					}
				<#else>
					validate_${memberTypeName}( prefix + ".${member.getName()}", object.${getterName} );
				</#if>
				}
			</#if>
		</#list>
		}
	</#list>
	}

	/**
	 * dynamic write ${ARfname} to json
	 */
	public static void writeDynamic( com.fasterxml.jackson.core.JsonGenerator jg, ${ARfname} object ) throws java.io.IOException {
		<#if function.getArguments() ?size !=0 >
		write( jg, object );
		<#else>
		// don't serialize empty request
		</#if>
	}
	
	/**
	 * dynamic read ${ARfname} from json
	 */
	public static ${ARfname} readDynamic( com.fasterxml.jackson.core.JsonParser jp ) throws java.io.IOException {
		if( jp.getCurrentToken() == null ) {
			jp.nextToken();
		}
		if( jp.getCurrentToken() == null || jp.getCurrentToken() == com.fasterxml.jackson.core.JsonToken.VALUE_NULL ) {
			return new ${ARfname}();
		}
		if( jp.getCurrentToken() != com.fasterxml.jackson.core.JsonToken.START_OBJECT ) {
			throw new com.fasterxml.jackson.core.JsonParseException( jp,
				"expected  object of type '${ARfname}'" );
		}
		return read( jp );
	}
	
<@my.writeMembersFunction items=function.getArguments() className=ARfname baseClassName=baseClassName classPackage=className serializerPrefix=serializerPrefix/>

<@my.readMemberFunction items=function.getArguments() className=ARfname classPackage="" />

<@my.memberReaders items=function.getArguments() className=ARfname classPackage="" serializerPrefix=serializerPrefix />
}

/**************************************************************************************************************
 * function ${APfname}
 * 
 **************************************************************************************************************/
public static final class ${APfname} {
	<#if returnTypeName != "void" >
	private ${returnType} returnValue;
	</#if>
	private java.lang.Exception exception;	
	<#list exceptions as exception >
	
	public void setException( ${modelJavaPackage}.${exception} exception ) {
		this.exception = exception;
	}
	
	public ${APfname} withException( ${modelJavaPackage}.${exception} exception ) {
		this.exception = exception;
		return this;
	}
	</#list>
	
	public void setExeption( ${modelJavaPackage}.exception.ServerException exception ) {
		this.exception = exception;		
	}

	public ${APfname} withException( ${modelJavaPackage}.exception.ServerException exception ) {
		this.exception = exception;	
		return this;
	}
	<#if returnTypeName != "void" >

	/**
	 * sets return value
	 */
	public void setReturnValue( ${returnType} returnValue ) {
		this.returnValue = returnValue;
	}
	
	/**
	 * gets return value
	 */
	public ${returnType} getReturnValue() {
		return returnValue;
	}
	
	/**
	 * sets return value
	 */
	public ${APfname} withReturnValue( ${returnType} returnValue ) {
		this.returnValue = returnValue;
		return this;	
	}
	</#if>
	
	/**
	 * throw the exception if there is any
	 */
	public void throwException() <@my.throwsExceptions items=exceptions end="{"/>
		if( exception == null ) {
			return;
		}
		if( exception instanceof ${modelJavaPackage}.exception.ServerException ) {
			throw (${modelJavaPackage}.exception.ServerException) exception;
		}
	<#list exceptions as exception >
		if( exception instanceof ${modelJavaPackage}.${exception} ) {
			throw (${modelJavaPackage}.${exception}) exception;
		}
	</#list>
	}

	/**
	 * dynamic write ${APfname} to json
	 */
	public static void writeDynamic( com.fasterxml.jackson.core.JsonGenerator jg, ${APfname} object ) throws java.io.IOException {
		if( object.exception != null ) {
			jg.writeStartObject();
			jg.writeFieldName( "exception" );
			WRITER_MAPPING.get( object.exception.getClass() ).write( jg, object.exception );
			jg.writeEndObject();
			return;
		}
<#if returnTypeName != "void" >
		jg.writeStartObject();
		${serializerPrefix}${returnTypeName}Serializer.writeValue( jg, "result", object.returnValue, "${APfname}" );
		jg.writeEndObject();
</#if>
	}
	
	/**
	 * dynamic write ${APfname} to json
	 */
	public static ${APfname} readDynamic( com.fasterxml.jackson.core.JsonParser jp ) throws java.io.IOException {
		if( jp.getCurrentToken() == null ) {
			jp.nextToken();
		}
		if( jp.getCurrentToken() == null || jp.getCurrentToken() == com.fasterxml.jackson.core.JsonToken.VALUE_NULL ) {
			return new ${APfname}();
		}
		if( jp.getCurrentToken() != com.fasterxml.jackson.core.JsonToken.START_OBJECT ) {
			throw new com.fasterxml.jackson.core.JsonParseException( jp,
				"expected  object of type ${APfname}" );
		}
		
		${APfname} result = new ${APfname}();
		
		while( jp.nextToken() == com.fasterxml.jackson.core.JsonToken.FIELD_NAME ) {
			java.lang.String fieldName = jp.getCurrentName();			
			jp.nextToken();
			if( fieldName == "exception" ) {
				result.exception = ${modelJavaPackage}.u.Lib.readDynamicType( jp, READER_MAPPING, null, "Exeption" );
			} <#if returnTypeName != "void" >else if ( fieldName == "result" ) {
				result.returnValue = ${serializerPrefix}${returnTypeName}Serializer.${readFunctionName}( jp, "result", "${returnTypeName}" );
			} </#if>else {
				jp.skipChildren();
			}
		}
		
		return result;
	}	
	
	/**
	 * ${className} WRITER_MAPPING
	 */
	@SuppressWarnings("serial")
	private static final java.util.Map<java.lang.Class<?>, ${modelJavaPackage}.u.Lib.JsonWriter> WRITER_MAPPING = 
		new java.util.HashMap<java.lang.Class<?>, ${modelJavaPackage}.u.Lib.JsonWriter>() {{
			putAll( ${modelJavaPackage}.json.exception.RuntimeExceptionSerializers.WRITERS );
	<#list allExceptions as exception >
			put( ${modelJavaPackage}.${exception}.class,${modelJavaPackage}.json.${exception}Serializer.WRITER );	
	</#list>	
		}};
		
	/**
	 * ${className} READER_MAPPING
	 */		
	@SuppressWarnings("serial")
	private static final java.util.Map<java.lang.String, ${modelJavaPackage}.u.Lib.JsonReader<? extends java.lang.Exception>> READER_MAPPING = 
		new java.util.HashMap<java.lang.String, ${modelJavaPackage}.u.Lib.JsonReader<? extends java.lang.Exception>>() {{
			putAll( ${modelJavaPackage}.json.exception.RuntimeExceptionSerializers.READERS );
		<#list allExceptions as exception >
			put( "${exception}", ${modelJavaPackage}.json.${exception}Serializer.READER );
		</#list>				
		}};
}
</#list>
}